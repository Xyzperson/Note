---
title: 类和对象
tags:
  - Java
---
# 类和对象

## 引用

相当于c里的指针，但是java里的引用只能指向对象

## 继承

一个类可以通过 extends 从父类继承 方法和属性

## 构造方法

通过一个类创建一个对象，叫做实例化

实例化是通过调用构造方法(构造器)实现的

- 方法名和类名一样
- **没有返回类型**
- 实例化一个对象时，必然调用构造方法
- 继承的类实例化时，父类的构造方法在子类前定义，调用，且不可更改顺序
- 如果提供了一个**有参**的构造方法，同时**没有**提供**无参**的构造方法，那么默认的无参构成方法会**覆盖**，需要重新定义
  - 但构造方法可以**重载**

## this

代表当前对象

- 如果要在一个构造方法中调用另一个构造方法，可以使用this()



## 访问修饰符

1. public
2. protected
3. package/default/friendly
4. private

### 类间的关系

- 自身
- 同包子类   B是A的子类，且和A处于同一个包下
- 异包子类   B是A的子类，但在另一个包下
- 同包类    B和A是同一个包，但彼此没有继承关系
- 其他类    B和A在不同的包下，也没有继承关系

| 修饰符    | 自身   | 同包子类 | 不同包子类 | 同包类   | 其他类   |
| --------- | ------ | -------- | ---------- | -------- | -------- |
| private   | 可访问 | 不能继承 | 不能继承   | 不可访问 | 不可访问 |
| default   | 可访问 | 可继承   | 不能继承   | 可访问   | 不可访问 |
| protected | 可访问 | 可继承   | 可继承     | 可访问   | 不可访问 |
| public    | 可访问 | 可继承   | 可继承     | 可访问   | 可访问   |

使用情况

1.  **属性**通常使用**private**封装起来
2. **方法**一般使用**public**用于被调用
3. 会被**子类继承**的方法，通常使用**protected**
4. package用的不多，一般新手会用package,因为还不知道有修饰符这个东西

**作用范围最小原则**

能用private就用private，不行就放大一级，用package,再不行就用protected，最后用public。 这样就能把数据尽量的封装起来，没有必要**露出来的**，就不用**露出来**了





## 类属性(static)

- 当一个属性被**static**修饰的时候，就叫做**类属性**，又叫做**静态属性**

- 当一个属性被声明成类属性，那么**所有的对象，都共享一个值** 

**类属性与对象属性不同**：

- 不同对象的 **对象属性** 的值都可能不一样
- 所有对象的**类属性**的值，都是一样的

访问

访问类属性两种方式：

- 对象.类属性
- 类.类属性(推荐)

## 类方法

- **类方法：** 又叫做静态方法
- **对象方法：** 又叫实例方法，非静态方法

区别：访问一个对象方法，必须**建立在有一个对象**的前提的基础上，访问类方法，**不需要对象**的存在，直接就访问

访问类属性一样，调用类方法两种方式

- 对象.类属性
- 类.类属性(推荐)

使用原则：

- 如果在某一个方法里，调用了对象属性，那么这个方法，就必须设计为对象，存在一个具体对象的时候，对象属性才有意义
- 如果一个方法，没有调用任何对象属性，那么就可以考虑设计为类方法
  - 这样的方法，更带有**功能性**色彩就像取随机数一样，`Math.random()`是一个功能用途的方法



> 静态方法、静态属性都是跟着类加载
>
> 静态方法优先对象方法加载进内存，若在类方法中调用对象方法，则无法加载对象方法



## 属性初始化

对象属性初始化方式：

1. 声明该属性的时候初始化
2. 构造方法中初始化
3. 初始化块

```java
public class Test {
    public String str = "hello";	//声明该属性的时候初始化
    protected float a;
    float b;
    
    {
        b = 200;		//初始化块
    }
    
    public test(){
        a = 100;		//构造方法中初始化
    }
}
```

对象属性初始化方式：

1. 声明该属性的时候初始化
2. 静态初始化块

```java
public class Test {
    public static float ver = 1.2F;
    static {
        ver = 1.3F;
    }
}
```

> 因为static静态属性，随着类初始化而初始化，而构造方法要在初始化对象时才能初始化属性，因此没有放在构造方法中的初始化方法
>
> 即初始化顺序：静态变量、静态初始化块）>（变量、初始化块）>构造器

## 单例模式

又叫做 Singleton模式，指的是一个类，在一个JVM里，只有一个实例存在。

三元素
1. 构造方法私有化
2. 静态属性指向实例
3. public static的 getInstance方法，返回第二步的静态属性

--------------



- 饿汉式单例模式

- 懒汉式单例模式

```java
//饿汉式单例模式
public class SingleObject {

   //让构造方法为 private，这样该类就不会被实例化
   private SingleObject(){}
  
   //创建 SingleObject 的一个对象
   private static SingleObject instance = new SingleObject();
 
   //获取唯一可用的对象
   public static SingleObject getInstance(){
      return instance;
   }
}
//懒汉式
public class Singleton {  
    private static Singleton instance;  
    private Singleton (){}  
  
    public static Singleton getInstance() {  
        if (instance == null) {  
            instance = new Singleton();  
        }  
    	return instance;  
    }  
}
```

>**饿汉式**是立即加载的方式，无论是否会用到这个对象，都会加载。
>如果在构造方法里写了性能消耗较大，占时较久的代码，比如建立与数据库的连接，那么就会在启动的时候感觉稍微有些卡顿。
>
>**懒汉式**，是延迟加载的方式，只有使用的时候才会加载。使用懒汉式，在启动的时候，会感觉到比饿汉式略快，因为并没有做对象的实例化。 但是在第一次调用的时候，会进行实例化操作，感觉上就略慢。
>
>看业务需求，如果业务上允许有比较充分的启动和初始化时间，就使用饿汉式，否则就使用懒汉式
>
>想看更多详细的可以找找 java设计模式的单例模式

## 枚举(enum)

枚举是一种特殊的类，使用枚举可以很方便的定义常量

```java
public enum Season {
	SPRING,SUMMER,AUTUMN,WINTER
}

public class HelloWorld {
    public static void main(String[] args) {
        for (Season s : Season.values()) {
            System.out.println(s);
        }
    }
}
```

> 因为是常量，所以一般都是全大写





